https://www.cve.org/CVERecord?id=CVE-2025-48734

BeanIntrospector class added in 1.9.2
Intended to stop access to classloader
but not enabled by default

https://cwe.mitre.org/data/definitions/284.html

disclosure thread:
https://lists.apache.org/thread/s0hb3jkfj5f3ryx6c57zqtfohb0of1g9
28 May 2025


Added in:
https://github.com/apache/commons-beanutils/releases/tag/BEANUTILS_1_9_2
May 29, 2014

src
- vuln
	https://github.com/apache/commons-beanutils/releases/tag/rel%2Fcommons-beanutils-1.10.1

- fixed
	https://github.com/apache/commons-beanutils/releases/tag/rel%2Fcommons-beanutils-1.11.0String

fix
https://github.com/apache/commons-beanutils/commit/bd20740da25b69552ddef8523beec0837297eaf9

questions:
#### What is a BeanUtils?
https://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly
- set of utility classes that that provide utility functions for java beans
	- JavaBeans convention
		1. All properties are private (use [getters/setters](http://en.wikipedia.org/wiki/Mutator_method))
		2. A public [no-argument constructor](http://en.wikipedia.org/wiki/Nullary_constructor)
		3. Implements [`Serializable`](http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html).
Serialisable is enabled when a class implements java.io.Serializable interface.
Implementing this allows the class to have serialised and desiarilized states.
No methods, only sematic

Serialisable objects can be written to streams and thus files, objects, databases etc
can basically make anything you want (according to stack overflow guy, reputable)
Convert instance to a stream of bytes which can then be transmitted over the network to another device, stored in files
Has enough info to allow a JVM to reconstruct it later (supposing the JVM knows the type)

Additionally.
instance fields must be primitives.

#### What's the issue
https://github.com/apache/commons-beanutils/commit/bd20740da25b69552ddef8523beec0837297eaf9

in PropertyUtilsBean.java 
https://github.com/apache/commons-beanutils/blob/3873f941d5e839e9fda43117be5a89d8e708e9a2/src/main/java/org/apache/commons/beanutils2/PropertyUtilsBean.java#L70

We have a getProperty(bean, name) or getNestedProperty() method
- getProperty
	- It get's the value of a specified property for the bean 
	- Line 617 calls getNestedProperty 
- getNestedProperty line 571
	- can access nested properties 
	- Uses resolver
	- https://github.com/apache/commons-beanutils/blob/master/src/main/java/org/apache/commons/beanutils2/expression/DefaultResolver.java
		- Resolves Property Names
			- 5 ways
				- Simple : 
					- individual property: Object.name
					- property xyz -> getXyz
				- Nested : 
					- Object.name1.name2.name3 ...
					- recursive lookup
				- Indexed : 
					- property in array
				- Mapped : 
					- property in map
				- Combined :  
					- name1.name2[index].name3(key) 
					- Combining mapped, nested, and indexed references is also supported.
Final call:
https://github.com/apache/commons-beanutils/blob/3873f941d5e839e9fda43117be5a89d8e708e9a2/src/main/java/org/apache/commons/beanutils2/PropertyUtilsBean.java#L933
getSimpleProperty()
... follow this chain down basically
We get the accessible method
following the code:
https://github.com/apache/commons-beanutils/blob/master/src/main/java/org/apache/commons/beanutils2/MethodUtils.java#L402

https://github.com/apache/commons-beanutils/blob/master/src/main/java/org/apache/commons/beanutils2/MethodUtils.java#L141

method.setAccessible(true);
source code in java - later

tldr: resolve the name to a descriptor then use that to search for a reference to the method

Important privileged check:
https://github.com/apache/commons-beanutils/blob/master/src/main/java/org/apache/commons/beanutils2/MethodUtils.java#L1103
Possible reason why the introspector is needed?

https://github.com/apache/commons-beanutils/blob/master/src/main/java/org/apache/commons/beanutils2/MethodUtils.java#L178

then use invokeMethod()

### Problem
Problem arises when accessing the enum properties.
accessing "declaredClass" allows us access to the class loader. 

This is done by accessing the "declaredClass" property of the enum.
Once accessed an attacker can access the ClassLoader and execute arbitrary code 

If we expose: someObjectWithAnEnum to an attacker 
e.g.) getProperty(someObjectWithAnEnum, "TestEnum.declaringClass");
First 
https://github.com/apache/commons-beanutils/blob/master/src/main/java/org/apache/commons/beanutils2/PropertyUtilsBean.java#L571
Resolver will use the getters tr return the declaringClass of the TestEnum
- possible since java.lang.Enum implements `getDeclaringClass`
- https://www.geeksforgeeks.org/java/class-getdeclaringclass-method-in-java-with-examples/
- https://docs.oracle.com/javase/9/docs/api/java/lang/Class.html#getDeclaringClass--
This will return a class of type `Class<TestEnum>` 
Once we have that we can get the class loader:
getNestedProperty(fixture, "testEnum.declaringClass.classLoader"));
Then we can load our own code

#### fix
add
introspectors.add(SuppressPropertiesBeanIntrospector.SUPPRESS_DECLARING_CLASS);
to PropertyUtilsBean.java

What this does:
- getNestedProperty
- getPropertyXBean
- getPropertyDescriptor
- getIntrospectionData (what properties are available on the bean)
- fetchIntrospectionData 
	- Use BeanIntrospector
	- For each BeanIntrospector call introspect(ictx) -> where introspection occurrs
	- When the `SuppressPropertiesBeanIntrospector` eventually get's callled 
		- Removes properties from the IntrospectionContext
		- https://github.com/apache/commons-beanutils/blob/master/src/main/java/org/apache/commons/beanutils2/SuppressPropertiesBeanIntrospector.java
		- It suppresses property names 
			- Iterates through `propertyNames`
			- then removes the PropertyDescriptor for that name
If you now try "testEnum.declaringClass.classLoader" It won't find anything 




#### joern
cpg.typeDecl.name("PropertyUtilsBean").method.name("resetBeanIntrospectors").headOption.code.l





Extra
**Apache Commons BeanUtils** is a Java library from the Apache Commons project that provides easy-to-use utility classes for working with **JavaBeans** — objects that follow the standard JavaBean conventions (i.e., have private properties with public getters and setters).

### **Main Uses of BeanUtils**

1. **Property Copying Between Beans**
    - Copy values from one bean to another, especially useful when transforming data between layers (e.g., DTO ↔ Entity).
    - Example:
        ```java
        BeanUtils.copyProperties(destBean, sourceBean);
        ```
2. **Dynamic Property Access**
    - Read or write bean properties by name (as strings) without directly calling the getter or setter.
    - Useful for frameworks and tools that need to manipulate objects without compile-time knowledge of their structure.
    - Example:
        ```java
        String name = (String) BeanUtils.getProperty(bean, "name");
        BeanUtils.setProperty(bean, "name", "John Doe");
        ```
3. **Population from Maps**
    - Populate a bean’s properties from a `Map<String, Object>`, typically used for handling form submissions or JSON parsing.
    - Example:
        ```java
        BeanUtils.populate(bean, paramMap);
        ```
4. **Nested Property Access**
    - Supports accessing and setting nested and indexed properties.
    - Example:
        ```java
        BeanUtils.getProperty(bean, "address.street");
        ```
---

### **Common Use Cases**
- Mapping HTTP request parameters to JavaBeans in web apps.
- Mapping between different object types in layered architecture.
- Simplifying reflection-based operations.

---

### **Caveats**

- BeanUtils uses reflection and is not very fast — for performance-sensitive applications, alternatives like **MapStruct** or **ModelMapper** are preferred.
- It doesn't handle complex type conversions out of the box.





