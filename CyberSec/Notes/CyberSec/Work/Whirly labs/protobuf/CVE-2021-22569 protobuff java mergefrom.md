https://nvd.nist.gov/vuln/detail/cve-2021-22569
https://github.com/advisories/GHSA-wrvw-hg22-4m67

Protocol Buffers
- language independent way of serializing structured data.
- smaller and faster than json
- tldr quick comms


protobuf-java
- interleave "com.google.protobuf.UnknownFieldSet"
- such that they're processed out of order
- Malicious payload can create a large amount of short lived objects that cause pauses

Vuln 

disclosure
https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39330
https://issues.oss-fuzz.com/issues/42502567

Detailed report: (locked)
https://oss-fuzz.com/testcase-detail/6156425441705984

poc (just a binary)
https://oss-fuzz.com/testcase?key=6156425441705984

fun

File
https://github.com/protocolbuffers/protobuf/blob/v3.16.1/java/core/src/main/java/com/google/protobuf/UnknownFieldSet.java


What does UnknownFieldSet do:
- Keep tracks of fields when parsing a protocol message 
- Field number or types are unrecognised
- Occurs when new fields are added, but the service communicates to an older service using the outdated fields 

e.g.)
If

`message Person {`
  `string name = 1;`
  `int32 age = 2; // new field`
`}`

Is send to a old service, field 2 will be stored as an "UnknownFieldSet" type 
provides for:
- Backward compat
- stored seq
- can access values, but not type of field


commit to fix + performance additions 
https://github.com/protocolbuffers/protobuf/pull/9371/files#diff-7604756079bfd12526943838070bdcf86b1cccde16c06e60ca0315946ee44cec

Vulnerable:
https://github.com/protocolbuffers/protobuf/blob/v3.16.0/java/core/src/main/java/com/google/protobuf/UnknownFieldSet.java


Looking at fix commit:
potential leads:
- line 86 removal 
	- Suspicion 
	- "The map is expected to be immutable"
- line 312 removal 
	- Suspicion
	-  // Optimization:  We keep around a builder for the last field that was
    - //   modified so that we can efficiently **add to it multiple times in a**
    - **//   row** (important when parsing an unknown repeated field).
- ~~line 407~~
- ~~line 439 mergefield from == to <=~~

Line 86
Default instance changed to a
`new TreeMap<Integer, Field>()`
Initially used regular maps
`Map<Integer, Field> fields;`

Line 308
Builder class
- Class maintains Field.Builder for all fields in the set
- Adding one element to an existing field does not require making a copy
- Field's can't be built independently
	- Line 712 
	- Field -> Five lists of values
		- Each list corresponds to a wire type 
			- used in the protocol buffer binary format
		- Wire types can be determined from encoded form
		- Don't need to know fields declared type
		- Allows us to parse unknown values and separate them
		- Wire types: varint, fixed32, fixed64, lengthDelimited, group ?
- Change from map to TreeMap L312
- create() function
	- Make a new builder
	- Runs reinitialize 
		- Set's:
			- fields = Collections.emptyMap()
			- lastFieldNumber = 0;
			- lastField = null;
	- returns this builder
- getFieldBuilder -> given an int, return the corresponding field 
- Re implemented in commit 
- Original
	- if lastField != null
		- If we're at the lastField, return the last field
		- else call addField `addField(lastFieldNumber, lastField.build());`
			- build() called on lastField
				- Builds the field making the code builder unusable.
				- If the field type is not null
					- create a list
					- Collections.unmodifiableList(result.TYPE);
		- Also reimplemented 
		- Og: 
			- If we're at the last number, set lastField to null
			- If lastField.build() is empty 
				- fields = new TreeMap<Integer, Field>();
					- Create a new TreeMap
					- TreeMap are always sorted (maybe here?)
			- Put the number and field into the fieldsTreeMap
			- return this
		- New:
			- fieldBuilders.put(number, Field.newBuilder(field));
	- Else
		- set existing to fields.get(number);
		- update lastFieldNumber
		- set lastField
		- call lastField.mergeFrom(existing);
			- mergeFrom
				- Minor change
				- Merges fields from existing into this set?
				- If the field exists in both sets, appends others values 
- New
	- get the builder for the number
	- call newBuilder()
		- unchanged
	- fieldBuilders.put(number, builder);
	- return the builder
- No longer using last field thing 
- getFieldBuilder(0); removed from alot of places 


Potential Vulnerability
UnknownFieldSet.Builder is used to build UnknownFieldSet.Field
UnknownFieldSet.Field should be immutable once built
UnknownFieldSet.Field should not be able to be built directly 
Store the last field that we operated on.

When we request a a new FieldBuilder though `getFieldBuilder`
- Checks if the current field is the same as the last 
- If not we add it
	- While adding we call `lastField.build()`
	- Which returns an immutable Field
	- Then add it to the `fields` map
		- New entry or replace existing 
- current field becomes last field 

Vuln
Pass a set with many new fields with repeated field numbers interleaved between them.
each time lastField.build() is called we create a new data.
new data get's put into `Collections.unmodifiableList`

Cases for callling getFieldBuilder
- **Case 1**: getFieldBuilder(X) was not called before -> lastField != X
	- call lastField.build()
	- this creates an immutable Field object
	- add to fields map
		- TreeMap
			- spamming this cause alot of insertions into the tree map
			- with each insertion the tree needs to be rebalanced
			- consumes cpu, espeically when the tree get's large
	- reset lastField and lastFieldNumber.
	- Update lastField and lastFieldNumber for FieldX
		- Makes a new Field.newBuilder();
	- Return lastField

- **Case 2**: getFieldBuilder(1) was already called before on Field1.0
- we're now calling it for Field1.1 (same field number but different field value)
	- calling it again with a new field value and different `lastFieldNumber` (interleaved)
	- lastField.build() in addField
		- Creates a new immutable field 
		- add this new field to the fields map
	- Then look for an existing field number `final Field existing = fields.get(number);`
	- Finds the Field with the same number (1) that we passed in before.
	- Update lastField
	- then call `lastField.mergeFrom(existing);`
		- This merges contents of the old Field with the same number into the new Field Builder
- Following call:
	- getFieldBuilder(X) with X != 1
	- lastField.build() in addField 
		- Creates a new immutable Field object for Field1.1
		- Field1.1 put into fields map
		- Field1.0 is now eligible for garbage collection
	- If this is repeated alot the JVM has to waste time cleaning up the objects

joern
Make sure "lastField.mergeFrom(existing);" doesn't appear in the getFieldBuilder function
`cpg.method.name("getFieldBuilder").ast.isCall.where(_.methodFullName(".*mergeFrom.*")).where(_.argument.code("existing"))`


1 **
2
3
1
2
1 **
2
