
https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-8gq9-2x98-w8hf
https://nvd.nist.gov/vuln/detail/cve-2022-1941

A small (~500 KB) malicious payload can be constructed which causes the running service to allocate more than 3GB of RAM.

https://github.com/protocolbuffers/protobuf/compare/v3.18.2...v3.18.3



fix commit
https://github.com/protocolbuffers/protobuf/commit/f43ac49b91007501ce1683967b04dcfb47183478

parsing vulnerability for MessageSet type
- out of memory failures
- specially crafted message
	- multiple key-value per elements creates parsing issues
	- lead to a DoS against services receiving unsanitized input
- A specially crafted message with multiple key-value per elements creates parsing issues

Looking for:
- parsing of malformed MessageSet
- multiple key-value per elements (duplicated keys, diff values?)

Stuff affected by commit:
- `const char* ParseMessageSetItemTmpl` function 
		- `src/google/protobuf/extension_set_inl.h`
- `const char* _InternalParse` function 
		- `src/google/protobuf/wire_format.cc`
- `bool ParseMessageSetItemImpl` function
		- `src/google/protobuf/wire_format_lite.h`

New unit test
"    // Test parse the message via DynamicMessage."
line 662 in unit test file

create a new Message Object called msg

line 634 in wire_format_unittest.inc
" ASSERT_TRUE(message_set.ParseFromString(data));"
https://groups.google.com/g/protobuf/c/oKLb32LLIiM/m/fwx3pale184J
https://groups.google.com/g/protobuf/c/oKLb32LLIiM/m/5Ab2GrQzfoQJ
wtf, document your code properly smh 
`ParseFromString() expects protobuf binary format data (stored in a C++ string),`

get data from a String and store in msg
get the reflection for msg 
- https://protobuf.dev/reference/cpp/api-docs/google.protobuf.message/#Reflection
- "This interface contains methods that can be used to dynamically access and modify the fields of a protocol message."
create a FieldDescriptor Vector called fields 
use `reflection->ListFields(*msg, &fields);`
- https://protobuf.dev/reference/cpp/api-docs/google.protobuf.message/#Reflection.ListFields.details
- List all fields of the message which are currently set, except for unknown fields, but including extension known to the parser.
- Use [Reflection::GetUnknownFields()](https://protobuf.dev/reference/cpp/api-docs/google.protobuf.message/#Reflection.GetUnknownFields) or message.unknown_fields() to also get access to fields/extensions unknown to the parser.
Then `const auto& sub = reflection->GetMessage(*msg, fields[0]);`
- https://protobuf.dev/reference/cpp/api-docs/google.protobuf.message/#Reflection.MutableMessage.details
- No factory provided to use default factory 

line 682 `TEST(WireFormatTest, ParseMessageSetWithAnyTagOrder)`
https://github.com/protocolbuffers/protobuf/blob/v3.18.3/src/google/protobuf/wire_format_unittest.inc#L619
- BuildMessageSetItemStart
	- make a string for the wire-format tag for the start of a MessageSet object
- BuildMessageSetItemEnd
	- make a string for the wire-format tag for the end of a MessageSet object
- BuildMessageSetItemTypeID
	- string representing "type_id" field 
- BuildMessageSetTestExtension1
	- string for message data, default message is 123

ValidateTestMessageSet
- Takes in a test case and data
- Verifies that a `MessageSet` string can be correctly parsed
- Does this 3 times for 
	- `ParseFromString`
	- `ParseAndMergePartial`
	- `DynamicMessage`

line 693 in unit test
`TEST(WireFormatTest, ParseMessageSetWithDuplicateTags)`
Similar to `ParseMessageSetWithAnyTagOrder` but with duplicated tags and messages
- tags and messages can be placed at any field index
- duplicates are tested at various points
- also test for arbitrary orders

Note: 
https://protobuf.dev/programming-guides/encoding/
``message := (tag value)*`
A message is encoded as a sequence of zero or more pairs of tags and values.

`tag := (field << 3) bit-or wire_type`
A tag is a combination of a `wire_type`, stored in the least significant three bits, and the field number that is defined in the `.proto` file.

"Message Structure"
Note: Encoding should follow a 
- start typeId message end (in that order)
format
i.e.) typeId-message should be singular between each start and end 


The message with duplicated data get's fed into 
	- `ParseFromString`
	- `ParseAndMergePartial`
	- `DynamicMessage`
None of these functions had any state checks initially
so if an out of order message was passed out of order weird behaviour occurs

e.g.) ParseMessageSetItemTmpl
- duplicate id
`payload_read` is true 
payload still has another type id within
then call `_InternalParse`
this reinterprets the same payload again 
each time this happens a new `MessageLite* value` is created


joern 
Check for states
`cpg.file.name(".*wire_format.cc", ".*wire_format_lite.h", ".*extension_set_inl.h").ast.code(".*enum\\s+class\\s+State.*").nonEmpty`






---
