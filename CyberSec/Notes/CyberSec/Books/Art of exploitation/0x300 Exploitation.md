Exploiting a program is a clever way of getting it to do what you want it to do even if the running program was designed to prevent this action. 
Security holes are design flaws
- can be simple for complex where advanced techniques are used 

Code can be like a genie, it'll so exactly what you ask it to do even if it does not adhere to the intended usage.

OpenSSH off by one error
![[Pasted image 20250328182914.png]]

When unicode was first introduced we had had multiple symbols for "/" which allowed users to access directories they should have had access to (from root)


## Generalised Exploit techniques

- Taking advantage of common mistakes that are hard to catch in development and production
- Buffer overflow and String exploits 
	- Take control of the targets execution flow by tricking it into running a piece of malicious code that has been smuggled into memory
	- Execution or arbitrary code
	- Normally causes a program to crash
	- Thus requires a careful control of the environment

# Buffer Overflows
Playing 10 bytes into a 9 byte buffer

C allows us to write beyond the buffer size, we can "contaminate" the next block/s of memory besides the buffer.

Corrupting memory allows us to control the execution flow of a program. 


### Stack based overflows
![[Pasted image 20250717115344.png]]

Note that auth flag starts with 0, b7, 08 ...
We see this pattern after the start of password buffer
Thus
password_buffer comes before auth_flag.
If we're able to overflow the value of password we can overwrite auth flag

![[Pasted image 20250717115624.png]]

The auth_flag which is a bool is now = 41, thus true

Note: Writing too far can crash the program:
![[Pasted image 20250717120003.png]]

When we call the auth function, stack frame is pushed onto the stack and EIP jumps to the first instruction of the function. 

Each stack frame contains the local variables for that function and a return address.
When the function is done the stack frame is popped and the return address is used to restore the EIP.
![[Pasted image 20250717120251.png]]

If done tactically we can over write the address of the return pointer so that the program executes the code that we want it to. 

Control flow of overwrite and stack pointer:
![[Pasted image 20250717122027.png]]
Stack pointer in main before calling auth function

![[Pasted image 20250717122108.png]]
Stack pointer after calling auth function:
- Note: esp start location is lower since we moved up the stack and placed check_auth. 
![[Pasted image 20250717122300.png]]

We spot the variables for the password buffer and auth flag now in esp.

Looking at the disass main
![[Pasted image 20250717123640.png]]

We see the address 080484bb after the check auth call, this will be the return address of the stack frame for check auth.

![[Pasted image 20250717123751.png]]

We some padding and the saved frame pointer in between the return address and the auth flag location.

At the end of auth 
![[Pasted image 20250717124132.png]]
leave and ret remove the stack frame and sets the eip to the return address.
Which should be the point before the function was called.

But

After writing into the buffer
![[Pasted image 20250717122611.png]]
Notice that we've overwritten the return address 
![[Pasted image 20250717124258.png]]

The program will still go ahead and set the eip to 0x41414141 but since this is basically a random location on memory the program crashes.
Since we technically control where this jumps to to we can get the program to jump to a specific location, but where?

# Bash

We can use command substitution and perl 
`$ u$(perl -e 'print "na";')me`
to quickly generate overflow text on the fly
`./overflow_example $(perl -e 'print "A"x30')`

![[Pasted image 20250717133146.png]]


![[Pasted image 20250717133748.png]]

A,B, C, and D have the hex values of 0x41, 0x42, 0x43, and 0x44
Which get's written into value

Writing our own number:
![[Pasted image 20250717133908.png]]

Note: Write in 2 byte chunks:
![[Pasted image 20250717134006.png]]

Writing 0xdeadbeef 
Need to use little endian.
![[Pasted image 20250717134115.png]]

Using this to change the return address:

![[Pasted image 20250717134801.png]]
Want to set the return address to access granted.

![[Pasted image 20250717134932.png]]

0x080484c6

![[Pasted image 20250717135321.png]]

But what if we want the program to use our own code?
The notesearch has this buffer overflow vuln
![[Pasted image 20250717135557.png]]


![[Pasted image 20250720121405.png]]

- Overflow input into program
	- Repeat our return address 40 times (return address is 4 byte)
	- This get's placed into command 
	![[Pasted image 20250720121909.png]]

- We then copy the value 0x90 to our buffer
- Then copy the shellcode into buffer+60

Now have:
- Long enough buffer to cause an overflow
- Executable code in the buffer
- Repeated return address

We now need to set the return address to our actual code.
Since it's hard to predict the the actual location of our shellcode during execution we can make use of a NOP sled. 

NOP -> assembly for no operation
- Single byte instruction that does nothing.
	- Useful for timing and cycling

Idea
- Create an array(sled) of of NOP instuctions.
- Place it before shellcode.
- When EIP hits this address it increments untill valid code is reached.
- We now just need to get the return address to be overwritten by any address in the NOP sled
- on x86 NOP is equivalent to 0x90 

Buffer:
![[Pasted image 20250720123220.png]]

But we still need an approximate location of our buffer.
To get this we can use a nearby stack location as a frame of reference. 
To do this we need to find the location of a variable within the target program. 

We use the fact that i is the first defined variable in our program and make the assumption that our target program also defines variables at the start of main. Using this assumption we have a general idea of where the the first variable get's assigned, we then make a follow up assumption that the buffer also get's defined some where nearby.

We then take the address of i and subtract and offset (stack grows down so i should be larger)

Guess various offsets until the return address is overwritten and our shell code is executed. 

Can use bash to automate guessing.
![[Pasted image 20250720135358.png]]
![[Pasted image 20250720135417.png]]

##### Using the environment
- Sometimes the buffer size may be too small to store shell code

We can store the shell code as an environment variable.
Convert shellcode to binary and store.

magic
![[Pasted image 20250720141554.png]]


Black magic 
![[Pasted image 20250720143325.png]]

The shellcode is now on the seack along with a 200byte NOP sled. 
We now just need to over write the return address to be somewhere in this range. 

Environment variables are located near the bottom of the stack.

Running notesearch and breaking at main we find:
![[Pasted image 20250720144433.png]]

bffff8f8 -> 3221223672
bffff9c0 -> 3221223872
halfway is around 3221223872
3221223872 -> bf ff f9 5c
We choose half since the actual location may differ in either direction

Needed to bruteforce a bit
![[Pasted image 20250720150449.png]]

We could use use getenv to get the actual location of the enviroment variable withing c.

![[Pasted image 20250720150723.png]]
This is not fully accurate though.
![[Pasted image 20250720151529.png]]

Length of the name has an effect on the location. 
Name of executing program affects location.
![[Pasted image 20250720151902.png]]

![[Pasted image 20250720152020.png]]
consistent changes.
We can take advantage of this to get precise location for a given program name
![[Pasted image 20250720152118.png]]

With all of this we don't need to make guesses anymore
![[Pasted image 20250720152406.png]]

![[Pasted image 20250720152508.png]]


pg 150



//change made
### `execl()`:
- Directly invokes the `notesearch` binary **with arguments**, bypassing the shell entirely.
- Your payload is passed **as-is** into `argv[1]`, preserving all binary data — NOPs, shellcode, return addresses, etc.
- There’s no interpretation, escaping, or truncation — so buffer overflows land exactly as expected.

System command might malform the payload as:
"system("./notesearch 'payload'");"
get's passed to the shell:
/bin/sh -c "./notesearch 'payload'"

which upon interpretation of the payload may malform it.

Use: `execl("./notesearch", "notesearch", buffer, NULL);`
Instead of `system(command);`


