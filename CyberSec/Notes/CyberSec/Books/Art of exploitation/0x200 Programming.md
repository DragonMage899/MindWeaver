What’s needed to overcome the complication of writing machine language
is a translator. An assembler is one form of machine-language translator—it is
a program that translates assembly language into machine-readable code.
Assembly language is less cryptic than machine language, since it uses names
for the different instructions and variables, instead of just using numbers


objdump -D a.out | grep -A20 main.:
	"The objdump program will spit out far too many lines of output to
	sensibly examine, so the output is piped into grep with the command-line
	option to only display 20 lines after the regular expression main.:"

This means a byte has 256 (2^8) possible
values, so each byte can be described with 2 hexadecimal digits.


![[Pasted image 20250118165154.png]]
The hexadecimal numbers—starting with 0x8048374 on the far left—are
memory addresses.

Intel syntax:
$ objdump -M intel -D a.out | grep -A20 main.:
![[Pasted image 20250125135636.png]]


![[Pasted image 20250125140042.png]]


![[Pasted image 20250125140618.png]]
bold is start of main
stuff before is the function prologue
- Set's up memory 


The display format also uses a single-letter shorthand, which is optionally
preceded by a count of how many items to examine. Some common format
letters are as follows:
	o Display in octal.
	x Display in hexadecimal.
	u Display in unsigned, standard base-10 decimal.
	t Display in binary

![[Pasted image 20250127112010.png]]


![[Pasted image 20250125142215.png]]

![[Pasted image 20250125142414.png]]
![[Pasted image 20250125142422.png]]
![[Pasted image 20250125142432.png]]

![[Pasted image 20250125151514.png]]
![[Pasted image 20250125151520.png]]
![[Pasted image 20250125151531.png]]
![[Pasted image 20250125151537.png]]


# 0x250 Dissembling first prog
![[Pasted image 20250127120520.png]]
break at main
address in the rip registers (points to current instruction in main)

## Things to note when displaying data:
- Data in memory can be views as desired can be
- Use x / ab
- a =
- ![[Pasted image 20250127120945.png]]
- b = 
- ![[Pasted image 20250127121001.png]]


## **Little Endian**
![[Pasted image 20250127121155.png]]

Unit sizes (b) are read from left to right in chunks

i.e) Least significant byte is stored first
![[Pasted image 20250127121535.png]]

![[Pasted image 20250127121627.png]]
![[Pasted image 20250127121642.png]]

## RIP
Note: rip points to an address containing instructions, thus viewing it instruction format will wield valid results (up to a certain point)
![[Pasted image 20250127121922.png]]

Note: Integers are 4 bytes
since i was decelerated we need to put it on the stack
thus i is located at base point minus 4

![[Pasted image 20250127122259.png]]
Currently contains garbage

## Side note: Print can be used to store addresses
![[Pasted image 20250127122536.png]]

Now use nexti
- The processor will read the instruction at RIP, execute it, and advance RIP to the next instruction.
![[Pasted image 20250127122738.png]]![[Pasted image 20250127122853.png]]
We've moved one instruction forward


![[Pasted image 20250127122932.png]]
also note that i was 0'd out

## **Next instructions**
![[Pasted image 20250127123115.png]]
Jump to main+36
cmp 9 with rbp-4
jle to main+17 if true {use eflags registers for comparison results}
else end

### in action
![[Pasted image 20250127123536.png]]

### next
![[Pasted image 20250127123634.png]]
![[Pasted image 20250127123732.png]]
![[Pasted image 20250127123845.png]]


We've moved the location of the start of "Hello World!"
into rax
then copied that into rdi
![[Pasted image 20250127124404.png]]

![[Pasted image 20250127124443.png]]
![[Pasted image 20250127124635.png]]
stuff ig
nex


### Looking for chars? use x/aub to spot ascii then x/acb to print ascii

![[Pasted image 20250127124927.png]]
rest is self explanatory


# 0x260
## null bytes in a string
- Tell's C when a string of char's ends
- str[a] = 0;
- stop's printing when null is read

Note: Setting each index individually is annoying
This use strcpy()
which copy's each byte one by one form source to destination 
Stop's when null is copied
![[Pasted image 20250127132255.png]]
![[Pasted image 20250127132648.png]]

## Pointers
![[Pasted image 20250127133720.png]]
![[Pasted image 20250127133755.png]]


## Format strings
![[Pasted image 20250127134134.png]]
![[Pasted image 20250127134156.png]]
Use format strings to sub in stuff and format the string


`printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);`
`printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);`
`printf("[field width on B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);`
`printf("[string] %s Address %08x\n", string, string);`

`// Example of unary address operator (dereferencing) and a %x format string`
`printf("variable A is at address: %08x\n", &A);`


![[Pasted image 20250127134547.png]]![[Pasted image 20250127134621.png]]
![[Pasted image 20250127134627.png]]


## Type casting
![[Pasted image 20250127134841.png]]


Stepping through a pointer of the wrong type
![[Pasted image 20250127135851.png]]

![[Pasted image 20250127135844.png]]
![[Pasted image 20250127135914.png]]
![[Pasted image 20250127135947.png]]


## Void ptr
![[Pasted image 20250127135959.png]]
![[Pasted image 20250127140109.png]]
![[Pasted image 20250127140116.png]]
![[Pasted image 20250127140217.png]]
![[Pasted image 20250127140224.png]]

## Command line args
![[Pasted image 20250127140343.png]]
![[Pasted image 20250127140426.png]]
![[Pasted image 20250127140500.png]]
![[Pasted image 20250127140513.png]]
![[Pasted image 20250127140520.png]]
![[Pasted image 20250127140534.png]]
![[Pasted image 20250127140717.png]]![[Pasted image 20250127140734.png]]
![[Pasted image 20250127141148.png]]


## Variable scoping
![[Pasted image 20250127141219.png]]
![[Pasted image 20250128082329.png]]

![[Pasted image 20250128082342.png]]
![[Pasted image 20250128083032.png]]
j redecalred in func3 (can use j but it points to a different addresss whilst in fun3)
reassigned global j in func 2


![[Pasted image 20250128082423.png]]
![[Pasted image 20250128082438.png]]
Static variable changes persists between function calls but can only be accessed when the call happens
Static variables only get initialised once
- also only recognised within a certain scope
- ![[Pasted image 20250128083251.png]]![[Pasted image 20250128083241.png]]

![[Pasted image 20250128083346.png]]


# 0x270 Memory Segmentation
![[Pasted image 20250128084639.png]]
![[Pasted image 20250128084716.png]]
![[Pasted image 20250128084747.png]]
![[Pasted image 20250128084819.png]]
![[Pasted image 20250128084904.png]]
![[Pasted image 20250128084946.png]]
![[Pasted image 20250128085649.png]]
![[Pasted image 20250128085805.png]]
![[Pasted image 20250128085846.png]]

![[Pasted image 20250128090817.png]]
![[Pasted image 20250128090822.png]]
![[Pasted image 20250128090929.png]]
![[Pasted image 20250128091507.png]]
![[Pasted image 20250128091516.png]]
pushed in reverse order (since filo)

![[Pasted image 20250128090938.png]]

![[Pasted image 20250128091624.png]]
![[Pasted image 20250128091612.png]]
![[Pasted image 20250128091734.png]]
![[Pasted image 20250128091757.png]]
![[Pasted image 20250128091835.png]]
![[Pasted image 20250128093214.png]]
![[Pasted image 20250128093221.png]]
![[Pasted image 20250128093450.png]]
![[Pasted image 20250128093233.png]]
![[Pasted image 20250128093459.png]]


![[Pasted image 20250128093823.png]]


## Memory segments in c
Static/global variables go into the data segment if init with data,
else they go into the bss segment.

if created with malloc, goes on heap, referenced with pointers.

Function variables go on the stack


![[Pasted image 20250128095716.png]]
![[Pasted image 20250128095834.png]]
![[Pasted image 20250128095853.png]]

# 0x280 Building on Basics
## File access 
- File Descriptor
- Filestreams

![[Pasted image 20250129143752.png]]

![[Pasted image 20250205165816.png]]
![[Pasted image 20250205165856.png]]
- Using or operation to set the flag for what we need
![[Pasted image 20250205173053.png]]
![[Pasted image 20250205173122.png]]
![[Pasted image 20250205173139.png]]

kinda kewl
- Doing OR operation adds (since unique)
- Addition results in code
## File Permissions 
![[Pasted image 20250205173301.png]]
![[Pasted image 20250205173311.png]]

![[Pasted image 20250205173615.png]]

## User IDs
![[Pasted image 20250205174303.png]]
![[Pasted image 20250205174528.png]]

**Since this file is owned by root and has the setuid permission**
**set, the program will run as the root user when any user runs this program.**

## Structs
![[Pasted image 20250205181941.png]]
![[Pasted image 20250205182749.png]]


## Function pointers
![[Pasted image 20250205182908.png]]![[Pasted image 20250205183054.png]]

## Pseudo-random Number
![[Pasted image 20250205183202.png]]
![[Pasted image 20250205183402.png]]
